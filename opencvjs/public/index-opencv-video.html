<!DOCTYPE html>
<html>
  <head>
    <title>opencv.js sandbox</title>
    <meta charset="UTF-8" />
    <style>
        /* The Modal (background) */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            padding-top: 100px; /* Location of the box */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgb(0,0,0); /* Fallback color */
            background-color: rgba(0,0,0,0.9); /* Black w/ opacity */
        }

        /* Modal Content (image) */
        .modal-content {
            margin: auto;
            display: block;
            width: 100%;
        }

        /* The Close Button */
        .close {
            position: absolute;
            top: 15px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            transition: 0.3s;
        }

        .close:hover,
        .close:focus {
            color: #bbb;
            text-decoration: none;
            cursor: pointer;
        }

        video {
            width: 100%;
            height: 100%;
            background: rgba(200, 0, 0, 0.2);
        }

        .canvasuser {
            /*
            margin: auto;
            display: block;
            */
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            background-color:rgba(255, 0, 0, 0.5);
        }
    </style>
  </head>

  <body>
    <div>
        <!--video id="videoInput" onplay="resize_canvas(this)"></video--> 
        <video id="videoInput"></video> 
        <canvas id="canvasUser" class="canvasuser"></canvas>
        <!--canvas id="canvasFilter" style="margin: auto;display: block;"></canvas-->
        <canvas id="canvasThreshold" style="margin: auto;display: block;"></canvas>
        <canvas id="canvasOutput" style="margin: auto;display: block;"></canvas>
        
        <!--img id="imageSrc" alt="No Image" />
        <div class="caption">imageSrc <input type="file" id="fileInput" name="file" /></div>
        <canvas id="canvasOutputGray"></canvas>
        <canvas id="canvasOutputThreshold"></canvas>
        <canvas id="canvasOutputCanny"></canvas>
        <canvas id="canvasOutputG"></canvas>
        <canvas id="canvasOutputCropped"></canvas-->
    </div>
    
    <!--button type="button" onclick="processPicture()">Take picture</button-->
    <button type="button" onclick="takePicture()">Take picture</button>

    <div id="myModal" class="modal">
        <span class="close">&times;</span>
        <!--img class="modal-content" id="img01"-->
        <canvas id="canvasCropped" class="modal-content"></canvas>
    </div>

    <!--script src="src/index.js"></script-->
    <script async src="../src/opencv.js" type="text/javascript"></script>
    <script>

        function resize_canvas(element)
        {
            console.log("element.offsetWidth",element.offsetWidth);
            console.log("element.videoWidth",element.videoWidth);
            console.log("element.offsetHeight",element.offsetHeight);
            console.log("element.getBoundingClientRect().height",element.getBoundingClientRect().height);
            var w = element.offsetWidth;
            var h = element.offsetHeight;
            var canvasuser = document.getElementById("canvasUser");
            canvasuser.width = w;
            canvasuser.height = h;
            let canvas_src = new cv.Mat(canvasuser.height, canvasuser.width, cv.CV_8UC4);
            cv.rectangle(canvas_src, new cv.Point(150, 50), new cv.Point(710, 430), new cv.Scalar(0,255,0,255), 2, cv.LINE_AA, 0);
            cv.imshow("canvasUser", canvas_src);
        }

        function takePicture(){
            var modal = document.getElementById("myModal");
            var modalCanvas = document.getElementById("canvasCropped");
            modal.style.display = "block";

            let src_to_crop = cv.imread('canvasOutput');
            let rectangle = new cv.Rect(150, 50, 560, 380); //rect = new cv.Rect(x, y, width, height);
            let cropped_image = src_to_crop.roi(rectangle);
            cv.imshow("canvasCropped", cropped_image);
            var close = document.getElementsByClassName("close")[0];

            close.onclick = function() { 
                modal.style.display = "none";
            }
        }

        let video = document.getElementById("videoInput");

        video.onplaying = function () {
            var width = video.videoWidth
            var height = video.videoHeight
            console.log("video dimens loaded w="+width+" h="+height)

            var canvasuser = document.getElementById("canvasUser");
            canvasuser.width = width;
            canvasuser.height = height;
            let canvas_src = new cv.Mat(canvasuser.height, canvasuser.width, cv.CV_8UC4);
            cv.rectangle(canvas_src, new cv.Point(150, 50), new cv.Point(710, 430), new cv.Scalar(0,255,0,255), 2, cv.LINE_AA, 0);
            cv.imshow("canvasUser", canvas_src);
        }
        

        if(video){
            //video.width = 860;
            //video.height = 480;
            navigator.mediaDevices.getUserMedia({   audio: false,
                                                    video: { 
                                                        facingMode:"environment",
                                                        width: { min: 1280, ideal: 1920, max: 2560 },
                                                        height: { min: 720, ideal: 1080, max: 1440 }, 
                                                    }
                                                })
            .then(function (stream) {
                video.srcObject = stream;
                video.play();
                
            
                let test = new cv.Mat();
                let cap = new cv.VideoCapture(video);
                let src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                let dst = new cv.Mat(video.height, video.width, cv.CV_8UC1);
                
                const FPS = 30;
                function processVideo() {
                    let src_clone = src.clone();
                    let src_user = src.clone();
                    let begin = Date.now();
                    cap.read(src);

                    // user template
                    // 860 x 480;
                    //cv.rectangle(src_user, new cv.Point(150, 50), new cv.Point(710, 430), new cv.Scalar(0,255,0,255), 2, cv.LINE_AA, 0);
                    
                    //cv.imshow("canvasUser", src_user);
                    //cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
                    //cv.rectangle(src, new cv.Point(200, 200), new cv.Point(400, 400), new cv.Scalar(0,255,0,255), 2, cv.LINE_AA, 0);
                    
                    
                    let ksize = new cv.Size(3, 3);
                    cv.GaussianBlur(src_clone, src_clone, ksize, 0, 0, cv.BORDER_DEFAULT);
                    //let dst_gray = new cv.Mat(height, width, cv.CV_8UC4);
                    let dst_gray = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                    cv.cvtColor(src_clone, dst_gray, cv.COLOR_BGR2GRAY, 0);

                    //let dst_thresh = new cv.Mat(height, width, cv.CV_8UC4);
                    let dst_thresh = new cv.Mat(video.height, video.width, cv.CV_8UC4);

                    /* Use cv.ADAPTIVE_THRESH_GAUSSIAN_C or cv.ADAPTIVE_THRESH_MEAN_C */
                    //cv.adaptiveThreshold(dst_gray, dst_thresh, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, 7, 2);
                    
                    /* Color range filter */
                    /*
                    cv.inRange(dst_gray, 
                        new cv.Mat(dst_gray.rows, dst_gray.cols, dst_gray.type(), [100, 100, 100, 0]), 
                        new cv.Mat(dst_gray.rows, dst_gray.cols, dst_gray.type(), [255, 250, 250, 255]),  
                        dst_thresh);
                    cv.imshow("canvasFilter", dst_thresh);
                    */

                    cv.threshold(dst_gray, dst_thresh, 100, 255, cv.THRESH_BINARY);
                    cv.imshow("canvasThreshold", dst_thresh);
                    

                    /* Dilate */
                    //let M = cv.Mat.ones(5, 5, cv.CV_8U);
                    //let anchor = new cv.Point(-1, -1);
                    //cv.dilate(dst_thresh, dst_thresh, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());

                    /* Contours */
                    let dst_cont = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(dst_thresh, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
                    let color = new cv.Scalar(255,0,0);
                    let max_per = 0;
                    let max_per_i = 0;
                    let max_area = 0;
                    let max_area_i = 0;
                    if (contours.size() > 0){
                        for (let i = 0; i < contours.size(); ++i) {
                            area = cv.contourArea(contours.get(i), false);
                            if (area > 3){
                                //cv.drawContours(dst_cont, contours, i, color, 1, cv.LINE_8, hierarchy, 100);
                                // Get the maximum area contour 
                                if (area > max_area){
                                    max_area = area;
                                    max_area_i = i;
                                }
                            }
                        }

                        let max_area_contour = contours.get(max_area_i);
                        let max_area_bb = cv.boundingRect(max_area_contour);
                        let max_area_bb_p1 = new cv.Point(max_area_bb.x, max_area_bb.y);
                        let max_area_bb_p2 = new cv.Point(max_area_bb.x + max_area_bb.width, max_area_bb.y + max_area_bb.height);
                        cv.rectangle(src_clone, max_area_bb_p1, max_area_bb_p2, new cv.Scalar(0,0,255,255), 2, cv.LINE_AA, 0);

                        // 860 x 480;
                        // cv.Point(150, 50) cv.Point(710, 430)

                        if(max_area_bb.x > 150){// &&  280 < max_area_bb.width && max_area_bb.width < 300){
                            if (max_area_bb.y > 50 && 520 < max_area_bb.width && max_area_bb.width < 540){
                                console.log("x",max_area_bb.x,"y",max_area_bb.y,"W",max_area_bb.width,"H",max_area_bb.height);
                                console.log("CAPTURED!!");
                                takePicture();
                            }
                        }
                    }
                    //cv.imshow("canvasOutput", src);
                    //cv.imshow("canvasOutput", dst_gray);
                    //cv.imshow("canvasOutput", dst_thresh);
                    
                    cv.imshow("canvasOutput", src_clone);
                    src_clone.delete(); 
                    src_user.delete();
                    dst_gray.delete(); 
                    dst_thresh.delete(); 
                    dst_cont.delete();
                    contours.delete(); 
                    hierarchy.delete();


                    // schedule next one.
                    let delay = 1000/FPS - (Date.now() - begin);
                    setTimeout(processVideo, delay);
                }
                // schedule first one.
                setTimeout(processVideo, 0);
            })
            .catch(function(err) {
                console.log("An error occurred! " + err);
            });
        }
    </script>
    
  </body>
</html>