<!DOCTYPE html>
<html>
  <head>
    <title>opencv.js sandbox</title>
    <meta charset="UTF-8" />
    <style>
        /* The Modal (background) */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            padding-top: 100px; /* Location of the box */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgb(0,0,0); /* Fallback color */
            background-color: rgba(0,0,0,0.9); /* Black w/ opacity */
        }

        /* Modal Content (image) */
        .modal-content {
            margin: auto;
            display: block;
            width: 80%;
            max-width: 700px;
        }

        /* The Close Button */
        .close {
        position: absolute;
        top: 15px;
        right: 35px;
        color: #f1f1f1;
        font-size: 40px;
        font-weight: bold;
        transition: 0.3s;
        }

        .close:hover,
        .close:focus {
        color: #bbb;
        text-decoration: none;
        cursor: pointer;
        }
    </style>
  </head>

  <body>
    <div>
        <video id="videoInput"></video> 
        <canvas id="canvasFilter"></canvas>
        <canvas id="canvasOutput"></canvas>
        
        <!--img id="imageSrc" alt="No Image" />
        <div class="caption">imageSrc <input type="file" id="fileInput" name="file" /></div>
        <canvas id="canvasOutputGray"></canvas>
        <canvas id="canvasOutputThreshold"></canvas>
        <canvas id="canvasOutputCanny"></canvas>
        <canvas id="canvasOutputG"></canvas>
        <canvas id="canvasOutputCropped"></canvas-->
    </div>
    
    <!--button type="button" onclick="processPicture()">Take picture</button-->
    <button type="button" onclick="takePicture()">Take picture</button>

    <div id="myModal" class="modal">
        <span class="close">&times;</span>
        <!--img class="modal-content" id="img01"-->
        <canvas id="canvasCropped" class="modal-content"></canvas>
    </div>

    <!--script src="src/index.js"></script-->
    <script async src="../src/opencv.js" type="text/javascript"></script>
    <script>
        /*
        let src;
        let imgElement = document.getElementById('imageSrc');
        let inputElement = document.getElementById('fileInput');
        inputElement.addEventListener('change', (e) => {
            imgElement.src = URL.createObjectURL(e.target.files[0]);
        }, false);

        imgElement.onload = function() {
            src = cv.imread(imgElement);
            processPicture();
        };
        */

        function takePicture(){
            
            //cv.imshow('canvasOutputCropped', cropped_image);
            var modal = document.getElementById("myModal");
            //var modalImg = document.getElementById("img01");
            var modalCanvas = document.getElementById("canvasCropped");
            modal.style.display = "block";
            //modalImg.src = "./logo192.png";

            let src_to_crop = cv.imread('canvasOutput');
            let rectangle = new cv.Rect(200, 200, 200, 200); //rect = new cv.Rect(x, y, width, height);
            let cropped_image = src_to_crop.roi(rectangle);
            cv.imshow("canvasCropped", cropped_image);
            var close = document.getElementsByClassName("close")[0];

            close.onclick = function() { 
                modal.style.display = "none";
            }
        }

        function processPicture(){
            let src_clone = src.clone();
            let ksize = new cv.Size(3, 3);
            cv.GaussianBlur(src_clone, src_clone, ksize, 0, 0, cv.BORDER_DEFAULT);
            let dst_gray = new cv.Mat();
            cv.cvtColor(src_clone, dst_gray, cv.COLOR_BGR2GRAY, 0);
            cv.imshow('canvasOutputGray', dst_gray);


            /* THRESHOLD */
            let dst_thresh = new cv.Mat();
            //cv.threshold(dst_gray, dst_thresh, 90, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);
            // cv.threshold(dst_gray, dst_thresh, 60, 70, cv.THRESH_BINARY);

            // Use cv.ADAPTIVE_THRESH_GAUSSIAN_C or cv.ADAPTIVE_THRESH_MEAN_C
            cv.adaptiveThreshold(dst_gray, dst_thresh, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, 7, 2);
            //cv.Sobel(dst_gray, dst_thresh, cv.CV_8U, 1, 0, 3, 1, 0, cv.BORDER_DEFAULT); // Vertical
            //cv.Sobel(dst_gray, dst_thresh, cv.CV_8U, 0, 1, 3, 1, 0, cv.BORDER_DEFAULT); // Horizontal
            cv.imshow('canvasOutputThreshold', dst_thresh);
            //cv.Canny(dst_thresh, dst_thresh, 50, 120, 3, false);
            let M = cv.Mat.ones(5, 5, cv.CV_8U);
            let anchor = new cv.Point(-1, -1);
            cv.dilate(dst_thresh, dst_thresh, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());
            cv.imshow('canvasOutputCanny', dst_thresh);
            //cv.threshold(dst_gray, dst_thresh, 120, 200, cv.THRESH_OTSU);
            //cv.threshold(src, dst_thresh, 145, 205, cv.THRESH_BINARY_INV);
            

            /* CONTOURS */
            let dst_cont = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(dst_thresh, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
            let color = new cv.Scalar(255,0,0);
            //console.log(contours);
            let max_per = 0;
            let max_per_i = 0;
            let max_area = 0;
            let max_area_i = 0;
            for (let i = 0; i < contours.size(); ++i) {
                perimeter = cv.arcLength(contours.get(i),true);
                area = cv.contourArea(contours.get(i), false);
                if (area > 340000){
                    cv.drawContours(dst_cont, contours, i, color, 1, cv.LINE_8, hierarchy, 100);
                }
                
                // Get the maximum perimeter contour 
                if (perimeter > max_per && perimeter < 2000){
                    max_per = perimeter;
                    max_per_i = i;
                }
                // Get the maximum area contour 
                if (area > max_area){
                    max_area = area;
                    max_area_i = i;
                }
                //let rect_contour = cv.boundingRect(contours.get(i));
                //cv.rectangle(dst_cont, new cv.Point(rect_contour.x, rect_contour.y), new cv.Point(rect_contour.x + rect_contour.width, rect_contour.y + rect_contour.height), new cv.Scalar(0,255,0), 2, cv.LINE_AA, 0);
            }
            //console.log("perimeter",max_per,"contour #", max_per_i);
            //console.log("area",max_area,"contour #", max_area_i);
            let cnt_per = contours.get(max_per_i);
            let cnt_area = contours.get(max_area_i);
            let rect_per = cv.boundingRect(cnt_per);
            let rect_area = cv.boundingRect(cnt_area);
            let point1_per = new cv.Point(rect_per.x, rect_per.y);
            let point2_per = new cv.Point(rect_per.x + rect_per.width, rect_per.y + rect_per.height);
            let point1_area = new cv.Point(rect_area.x, rect_area.y);
            let point2_area = new cv.Point(rect_area.x + rect_area.width, rect_area.y + rect_area.height);
            cv.rectangle(dst_cont, point1_per, point2_per, new cv.Scalar(0,255,0), 2, cv.LINE_AA, 0);
            cv.rectangle(dst_cont, point1_area, point2_area, new cv.Scalar(255,255,0), 2, cv.LINE_AA, 0);

            let rotatedRect = cv.minAreaRect(cnt_area);
            let vertices = cv.RotatedRect.points(rotatedRect);
            for (let i = 0; i < 4; i++) {
                cv.line(dst_cont, vertices[i], vertices[(i + 1) % 4], new cv.Scalar(155,155,100), 2, cv.LINE_AA, 0);
            }

            /*
            console.log("max:", max);
            console.log("max_i:", max_i);
            console.log("contours.get(max_i):", contours.get(max_i));
            let matVec = new cv.MatVector();
            matVec.push_back(contours.get(max_i));
            console.log("matVec.size()",matVec.size());
            console.log("matVec.get(0)",matVec.get(0));
            cv.drawContours(dst_cont, matVec, 0, color, 1, cv.LINE_8, hierarchy, 100);
            console.log("max:", max);
            */
            cv.imshow('canvasOutputG', dst_cont);

            //let cropped_image = src.roi(rect_area);
            //cv.imshow('canvasOutputCropped', cropped_image);
        }


        let video = document.getElementById("videoInput");
        if(video){
            video.width = 640;
            video.height = 480;
            width = 640;
            height = 480;
            navigator.mediaDevices.getUserMedia({ video: { facingMode:"environment" }, audio: false })
            .then(function (stream) {
                video.srcObject = stream;
                video.play();
            
                let test = new cv.Mat();
                let src = new cv.Mat(height, width, cv.CV_8UC4);
                let dst = new cv.Mat(height, width, cv.CV_8UC1);
                let cap = new cv.VideoCapture(video);
                const FPS = 30;
                function processVideo() {
                    let begin = Date.now();
                    cap.read(src);
                    //cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
                    //cv.rectangle(src, new cv.Point(200, 200), new cv.Point(400, 400), new cv.Scalar(0,255,0,255), 2, cv.LINE_AA, 0);
                    
                    let src_clone = src.clone();
                    let ksize = new cv.Size(3, 3);
                    cv.GaussianBlur(src_clone, src_clone, ksize, 0, 0, cv.BORDER_DEFAULT);
                    let dst_gray = new cv.Mat(height, width, cv.CV_8UC4);
                    cv.cvtColor(src_clone, dst_gray, cv.COLOR_BGR2GRAY, 0);

                    let dst_thresh = new cv.Mat(height, width, cv.CV_8UC4);

                    /* Use cv.ADAPTIVE_THRESH_GAUSSIAN_C or cv.ADAPTIVE_THRESH_MEAN_C */
                    //cv.adaptiveThreshold(dst_gray, dst_thresh, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, 7, 2);
                    
                    cv.inRange(dst_gray, 
                        new cv.Mat(dst_gray.rows, dst_gray.cols, dst_gray.type(), [100, 100, 100, 0]), 
                        new cv.Mat(dst_gray.rows, dst_gray.cols, dst_gray.type(), [255, 250, 250, 255]),  
                        dst_thresh);
                    cv.imshow("canvasFilter", dst_thresh);
                    

                    /* Dilate */
                    //let M = cv.Mat.ones(5, 5, cv.CV_8U);
                    //let anchor = new cv.Point(-1, -1);
                    //cv.dilate(dst_thresh, dst_thresh, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());

                    /* Contours */
                    
                    let dst_cont = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(dst_thresh, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
                    //console.log("after findContours, contours.size = ", contours.size());
                    let color = new cv.Scalar(255,0,0);
                    let max_per = 0;
                    let max_per_i = 0;
                    let max_area = 0;
                    let max_area_i = 0;
                    if (contours.size() > 0){
                        for (let i = 0; i < contours.size(); ++i) {
                            //perimeter = cv.arcLength(contours.get(i),true);
                            area = cv.contourArea(contours.get(i), false);
                            if (area > 3){
                                //cv.drawContours(dst_cont, contours, i, color, 1, cv.LINE_8, hierarchy, 100);
                                // Get the maximum area contour 
                                if (area > max_area){
                                    max_area = area;
                                    max_area_i = i;
                                }
                            }
                        }

                        
                        let max_area_contour = contours.get(max_area_i);
                        let max_area_bb = cv.boundingRect(max_area_contour);
                        let max_area_bb_p1 = new cv.Point(max_area_bb.x, max_area_bb.y);
                        let max_area_bb_p2 = new cv.Point(max_area_bb.x + max_area_bb.width, max_area_bb.y + max_area_bb.height);
                        cv.rectangle(src_clone, max_area_bb_p1, max_area_bb_p2, new cv.Scalar(255,0,0,255), 2, cv.LINE_AA, 0);
                        
                        
                    }
                    //cv.imshow("canvasOutput", src);
                    //cv.imshow("canvasOutput", dst_gray);
                    //cv.imshow("canvasOutput", dst_thresh);
                    
                    cv.imshow("canvasOutput", src_clone);
                    src_clone.delete(); 
                    dst_gray.delete(); 
                    dst_thresh.delete(); 
                    dst_cont.delete();
                    contours.delete(); 
                    hierarchy.delete();


                    // schedule next one.
                    let delay = 1000/FPS - (Date.now() - begin);
                    setTimeout(processVideo, delay);
                }
                // schedule first one.
                setTimeout(processVideo, 0);
            })
            .catch(function(err) {
                console.log("An error occurred! " + err);
            });
        }
    </script>
    
  </body>
</html>