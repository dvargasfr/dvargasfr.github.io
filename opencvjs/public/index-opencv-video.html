<!DOCTYPE html>
<html>
  <head>
    <title>opencv.js sandbox</title>
    <meta charset="UTF-8" />
    <style>
        /* The Modal (background) */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            padding-top: 100px; /* Location of the box */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgb(0,0,0); /* Fallback color */
            background-color: rgba(0,0,0,0.9); /* Black w/ opacity */
        }

        /* Modal Content (image) */
        .modal-content {
            margin: auto;
            display: block;
            width: 100%;
        }

        /* The Close Button */
        .close {
            position: absolute;
            top: 15px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            transition: 0.3s;
        }

        .close:hover,
        .close:focus {
            color: #bbb;
            text-decoration: none;
            cursor: pointer;
        }

        video {
            /*
            width: 100%;
            height: 100%;
            */
            position: absolute;
            left: 0;
            top: 0;
            background: rgba(200, 0, 0, 0.2);
        }

        .canvas-scan {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            background-color:rgba(255, 0, 0, 0.5);
        }
    </style>
  </head>

  <body>
    <div>
        <!--video id="videoInput" onplay="resize_canvas(this)"></video--> 
        <video id="videoInput"></video> 
        <div id="debugdiv" style="position:fixed"></div>
        <canvas id="canvasScan" class="canvas-scan"></canvas>
        <!--canvas id="canvasFilter" style="margin: auto;display: block;"></canvas-->
        <canvas id="canvasThreshold" style="margin: auto;display: block;"></canvas>
        <canvas id="canvasOutput" style="margin: auto;display: block;"></canvas>
        
        <!--img id="imageSrc" alt="No Image" />
        <div class="caption">imageSrc <input type="file" id="fileInput" name="file" /></div>
        <canvas id="canvasOutputGray"></canvas>
        <canvas id="canvasOutputThreshold"></canvas>
        <canvas id="canvasOutputCanny"></canvas>
        <canvas id="canvasOutputG"></canvas>
        <canvas id="canvasOutputCropped"></canvas-->
    </div>
    
    <!--button type="button" onclick="processPicture()">Take picture</button-->
    <button type="button" onclick="takePicture()">Take picture</button>

    <div id="myModal" class="modal">
        <span class="close">&times;</span>
        <!--img class="modal-content" id="img01"-->
        <canvas id="canvasCropped" class="modal-content"></canvas>
    </div>

    <!--script src="src/index.js"></script-->
    <script async src="../src/opencv.js" type="text/javascript"></script>
    <script>
        /*
        function resize_canvas(element)
        {
            console.log("element.offsetWidth",element.offsetWidth);
            console.log("element.videoWidth",element.videoWidth);
            console.log("element.offsetHeight",element.offsetHeight);
            console.log("element.getBoundingClientRect().height",element.getBoundingClientRect().height);
            _video_width = element.offsetWidth;
            _video_height = element.offsetHeight;
            var canvasuser = document.getElementById("canvasUser");
            canvasuser.width = _video_width;
            canvasuser.height = _video_height;
            
            var debugdiv = document.getElementById("debugdiv");
            debugdiv.innerHTML = _video_width + " x " + _video_height;
            let canvas_src = new cv.Mat(canvasuser.height, canvasuser.width, cv.CV_8UC4);
            cv.rectangle(canvas_src, new cv.Point(150, 50), new cv.Point(710, 430), new cv.Scalar(0,255,0,255), 2, cv.LINE_AA, 0);
            cv.imshow("canvasUser", canvas_src);
        }
        */

        let _video_width = 0;
        let _video_height = 0;
        let video = document.getElementById("videoInput");

        video.onplaying = function () {
            console.log("into video.onplaying");
            /*
            _video_width = element.offsetWidth;
            _video_height = element.offsetHeight;
            */

            _video_width = video.videoWidth;
            _video_height = video.videoHeight;
            console.log("video dimens loaded w="+_video_width+" h="+_video_height);
            var debugdiv = document.getElementById("debugdiv");
            debugdiv.style.top = _video_height + 20 + "px";
            debugdiv.innerHTML = _video_width + " x " + _video_height;
            //video.style.width = _video_width;
            //video.style.height = _video_height;

            var canvas_scan = document.getElementById("canvasScan");
            canvas_scan.width = _video_width;
            canvas_scan.height = _video_height;
            let canvas_scan_src = new cv.Mat(canvas_scan.height, canvas_scan.width, cv.CV_8UC4);
            //Selecciona el lado menor
            let orientation = _video_width < _video_height ? "portrait" : "landscape";
            console.log("orientation", orientation);
            //if (orientation == "landscape"){
                let detect_w = _video_width*0.8;
                let detect_h = detect_w/1.5;
                let tl_corner_x = _video_width*0.1;
                let tl_corner_y = (_video_height-detect_h)/2;
                let tl_corner = new cv.Point(tl_corner_x, tl_corner_y);
                let br_corner = new cv.Point(tl_corner_x+detect_w, tl_corner_y+detect_h);
                cv.rectangle(canvas_scan_src, tl_corner, br_corner, new cv.Scalar(0,255,0,255), 2, cv.LINE_AA, 0);

            //cv.rectangle(canvas_scan_src, new cv.Point(150, 50), new cv.Point(710, 430), new cv.Scalar(0,255,0,255), 2, cv.LINE_AA, 0);
            cv.imshow("canvasScan", canvas_scan_src);

            let cap = new cv.VideoCapture(video);
            console.log("aaa - ",video.offsetWidth);
            console.log("bbb - ", _video_height);
            let src = new cv.Mat(_video_height, _video_width, cv.CV_8UC4);
            console.log("ccc");
            let dst = new cv.Mat(_video_height, _video_width, cv.CV_8UC1);
            
            const FPS = 30;
            function processVideo() {
                let src_clone = src.clone();
                let src_user = src.clone();
                let begin = Date.now();
                cap.read(src);
                console.log("ddd");

                // user template
                // 860 x 480;
                //cv.rectangle(src_user, new cv.Point(150, 50), new cv.Point(710, 430), new cv.Scalar(0,255,0,255), 2, cv.LINE_AA, 0);
                
                //cv.imshow("canvasUser", src_user);
                //cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
                //cv.rectangle(src, new cv.Point(200, 200), new cv.Point(400, 400), new cv.Scalar(0,255,0,255), 2, cv.LINE_AA, 0);
                
                
                let ksize = new cv.Size(3, 3);
                cv.GaussianBlur(src_clone, src_clone, ksize, 0, 0, cv.BORDER_DEFAULT);
                //let dst_gray = new cv.Mat(height, width, cv.CV_8UC4);
                let dst_gray = new cv.Mat(_video_height, _video_width, cv.CV_8UC4);
                cv.cvtColor(src_clone, dst_gray, cv.COLOR_BGR2GRAY, 0);

                //let dst_thresh = new cv.Mat(height, width, cv.CV_8UC4);
                let dst_thresh = new cv.Mat(_video_height, _video_width, cv.CV_8UC4);

                /* Use cv.ADAPTIVE_THRESH_GAUSSIAN_C or cv.ADAPTIVE_THRESH_MEAN_C */
                //cv.adaptiveThreshold(dst_gray, dst_thresh, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, 7, 2);
                
                /* Color range filter */
                /*
                cv.inRange(dst_gray, 
                    new cv.Mat(dst_gray.rows, dst_gray.cols, dst_gray.type(), [100, 100, 100, 0]), 
                    new cv.Mat(dst_gray.rows, dst_gray.cols, dst_gray.type(), [255, 250, 250, 255]),  
                    dst_thresh);
                cv.imshow("canvasFilter", dst_thresh);
                */

                cv.threshold(dst_gray, dst_thresh, 100, 255, cv.THRESH_BINARY);
                cv.imshow("canvasThreshold", dst_thresh);
                

                /* Dilate */
                //let M = cv.Mat.ones(5, 5, cv.CV_8U);
                //let anchor = new cv.Point(-1, -1);
                //cv.dilate(dst_thresh, dst_thresh, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());

                /* Contours */
                let dst_cont = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(dst_thresh, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
                let color = new cv.Scalar(255,0,0);
                let max_per = 0;
                let max_per_i = 0;
                let max_area = 0;
                let max_area_i = 0;
                if (contours.size() > 0){
                    for (let i = 0; i < contours.size(); ++i) {
                        area = cv.contourArea(contours.get(i), false);
                        if (area > 3){
                            //cv.drawContours(dst_cont, contours, i, color, 1, cv.LINE_8, hierarchy, 100);
                            // Get the maximum area contour 
                            if (area > max_area){
                                max_area = area;
                                max_area_i = i;
                            }
                        }
                    }

                    let max_area_contour = contours.get(max_area_i);
                    let max_area_bb = cv.boundingRect(max_area_contour);
                    let max_area_bb_p1 = new cv.Point(max_area_bb.x, max_area_bb.y);
                    let max_area_bb_p2 = new cv.Point(max_area_bb.x + max_area_bb.width, max_area_bb.y + max_area_bb.height);
                    cv.rectangle(src_clone, max_area_bb_p1, max_area_bb_p2, new cv.Scalar(0,0,255,255), 2, cv.LINE_AA, 0);

                    // 860 x 480;
                    // cv.Point(150, 50) cv.Point(710, 430)

                    if(max_area_bb.x > 150){// &&  280 < max_area_bb.width && max_area_bb.width < 300){
                        if (max_area_bb.y > 50 && 520 < max_area_bb.width && max_area_bb.width < 540){
                            console.log("x",max_area_bb.x,"y",max_area_bb.y,"W",max_area_bb.width,"H",max_area_bb.height);
                            console.log("CAPTURED!!");
                            takePicture();
                        }
                    }
                }
                //cv.imshow("canvasOutput", src);
                //cv.imshow("canvasOutput", dst_gray);
                //cv.imshow("canvasOutput", dst_thresh);
                
                cv.imshow("canvasOutput", src_clone);
                src_clone.delete(); 
                src_user.delete();
                dst_gray.delete(); 
                dst_thresh.delete(); 
                dst_cont.delete();
                contours.delete(); 
                hierarchy.delete();


                // schedule next one.
                let delay = 1000/FPS - (Date.now() - begin);
                setTimeout(processVideo, delay);
            }
            // schedule first one.
            setTimeout(processVideo, 0);
        }
        
        navigator.mediaDevices.getUserMedia({   audio: false,
                                                video: { 
                                                    facingMode:"environment",
                                                    width: { min: 1280, ideal: 1920, max: 2560 },
                                                    height: { min: 720, ideal: 1080, max: 1440 }, 
                                                }
                                            })
        .then(function (stream) {
            video.srcObject = stream;
            video.play();
            console.log("after video.play()");
            


            /*****************
            let cap = new cv.VideoCapture(video);
            console.log("aaa");
            //while(_video_height === undefined){};
            console.log("bbb - ", _video_height);
            while (_video_height == 0){}
            let src = new cv.Mat(_video_height, _video_width, cv.CV_8UC4);
            console.log("ccc");
            let dst = new cv.Mat(_video_height, _video_width, cv.CV_8UC1);
            
            const FPS = 30;
            function processVideo() {
                let src_clone = src.clone();
                let src_user = src.clone();
                let begin = Date.now();
                cap.read(src);

                // user template
                // 860 x 480;
                //cv.rectangle(src_user, new cv.Point(150, 50), new cv.Point(710, 430), new cv.Scalar(0,255,0,255), 2, cv.LINE_AA, 0);
                
                //cv.imshow("canvasUser", src_user);
                //cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
                //cv.rectangle(src, new cv.Point(200, 200), new cv.Point(400, 400), new cv.Scalar(0,255,0,255), 2, cv.LINE_AA, 0);
                
                
                let ksize = new cv.Size(3, 3);
                cv.GaussianBlur(src_clone, src_clone, ksize, 0, 0, cv.BORDER_DEFAULT);
                //let dst_gray = new cv.Mat(height, width, cv.CV_8UC4);
                let dst_gray = new cv.Mat(_video_height, _video_width, cv.CV_8UC4);
                cv.cvtColor(src_clone, dst_gray, cv.COLOR_BGR2GRAY, 0);

                //let dst_thresh = new cv.Mat(height, width, cv.CV_8UC4);
                let dst_thresh = new cv.Mat(_video_height, _video_width, cv.CV_8UC4);

                /* Use cv.ADAPTIVE_THRESH_GAUSSIAN_C or cv.ADAPTIVE_THRESH_MEAN_C */
                //cv.adaptiveThreshold(dst_gray, dst_thresh, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, 7, 2);
                
                /* Color range filter */
                /*
                cv.inRange(dst_gray, 
                    new cv.Mat(dst_gray.rows, dst_gray.cols, dst_gray.type(), [100, 100, 100, 0]), 
                    new cv.Mat(dst_gray.rows, dst_gray.cols, dst_gray.type(), [255, 250, 250, 255]),  
                    dst_thresh);
                cv.imshow("canvasFilter", dst_thresh);
                *//*

                cv.threshold(dst_gray, dst_thresh, 100, 255, cv.THRESH_BINARY);
                cv.imshow("canvasThreshold", dst_thresh);
                

                /* Dilate */
                //let M = cv.Mat.ones(5, 5, cv.CV_8U);
                //let anchor = new cv.Point(-1, -1);
                //cv.dilate(dst_thresh, dst_thresh, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());

                /* Contours *//*
                let dst_cont = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(dst_thresh, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);
                let color = new cv.Scalar(255,0,0);
                let max_per = 0;
                let max_per_i = 0;
                let max_area = 0;
                let max_area_i = 0;
                if (contours.size() > 0){
                    for (let i = 0; i < contours.size(); ++i) {
                        area = cv.contourArea(contours.get(i), false);
                        if (area > 3){
                            //cv.drawContours(dst_cont, contours, i, color, 1, cv.LINE_8, hierarchy, 100);
                            // Get the maximum area contour 
                            if (area > max_area){
                                max_area = area;
                                max_area_i = i;
                            }
                        }
                    }

                    let max_area_contour = contours.get(max_area_i);
                    let max_area_bb = cv.boundingRect(max_area_contour);
                    let max_area_bb_p1 = new cv.Point(max_area_bb.x, max_area_bb.y);
                    let max_area_bb_p2 = new cv.Point(max_area_bb.x + max_area_bb.width, max_area_bb.y + max_area_bb.height);
                    cv.rectangle(src_clone, max_area_bb_p1, max_area_bb_p2, new cv.Scalar(0,0,255,255), 2, cv.LINE_AA, 0);

                    // 860 x 480;
                    // cv.Point(150, 50) cv.Point(710, 430)

                    if(max_area_bb.x > 150){// &&  280 < max_area_bb.width && max_area_bb.width < 300){
                        if (max_area_bb.y > 50 && 520 < max_area_bb.width && max_area_bb.width < 540){
                            console.log("x",max_area_bb.x,"y",max_area_bb.y,"W",max_area_bb.width,"H",max_area_bb.height);
                            console.log("CAPTURED!!");
                            takePicture();
                        }
                    }
                }
                //cv.imshow("canvasOutput", src);
                //cv.imshow("canvasOutput", dst_gray);
                //cv.imshow("canvasOutput", dst_thresh);
                
                cv.imshow("canvasOutput", src_clone);
                src_clone.delete(); 
                src_user.delete();
                dst_gray.delete(); 
                dst_thresh.delete(); 
                dst_cont.delete();
                contours.delete(); 
                hierarchy.delete();


                // schedule next one.
                let delay = 1000/FPS - (Date.now() - begin);
                setTimeout(processVideo, delay);
            }
            // schedule first one.
            setTimeout(processVideo, 0);
            */
        })
        .catch(function(err) {
            console.log("An error occurred! " + err);
        });

        function takePicture(){
            var modal = document.getElementById("myModal");
            var modalCanvas = document.getElementById("canvasCropped");
            modal.style.display = "block";

            let src_to_crop = cv.imread('canvasOutput');
            let rectangle = new cv.Rect(150, 50, 560, 380); //rect = new cv.Rect(x, y, width, height);
            let cropped_image = src_to_crop.roi(rectangle);
            cv.imshow("canvasCropped", cropped_image);
            var close = document.getElementsByClassName("close")[0];

            close.onclick = function() { 
                modal.style.display = "none";
            }
        }
    </script>
    
  </body>
</html>